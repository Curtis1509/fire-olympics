/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package fire.olympics;

import fire.olympics.display.*;
import fire.olympics.fontMeshCreator.FontFile;
import fire.olympics.fontMeshCreator.GUIText;
import fire.olympics.fontMeshCreator.FontType;
import fire.olympics.graphics.MeshText;
import fire.olympics.graphics.ModelLoader;
import fire.olympics.graphics.ShaderProgram;
import fire.olympics.graphics.Texture;

import static org.lwjgl.opengl.GL33C.*;

import org.lwjgl.*;
import org.lwjgl.glfw.GLFWErrorCallback;
import static org.lwjgl.glfw.GLFW.*;
import org.joml.Vector2f;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Objects;

public class App implements AutoCloseable {
    public static void main(String[] args) {
        Thread t = Thread.currentThread();
        if (!t.getName().equals("main")) {
            System.out.println("warning: not running on main thread!");
        }
        
        try (App app = new App(Path.of("app", "src", "main", "resources"))) {
            // app.createMainWindow();
            app.createMainWindow();
            app.mainLoop();
        } catch (Exception e) {
            System.out.printf("error: %s%n", e);
            e.printStackTrace();
        }
    }

    private Path resourcePath;
    private final ArrayList<Controller> controllers = new ArrayList<>();

    public App(Path resourcePath) {
        if (!Files.exists(resourcePath)) {
            this.resourcePath = Path.of("app").relativize(resourcePath);
        } else {
            this.resourcePath = resourcePath;
        }
        // Setup an error callback. The default implementation
        // will print the error message in System.err.
        GLFWErrorCallback.createPrint(System.err).set();
        // Initialize GLFW. Most GLFW functions will not work before doing this.
        if (!glfwInit()) {
            throw new IllegalStateException("Unable to initialize GLFW");
        }
    }

    public void mainLoop() {
        for (Controller c : controllers) {
            try {
                c.window.use();
                c.load();
                c.renderer.setAspectRatio(c.window.aspectRatio());
                c.window.done();
                c.window.showWindow();
            } catch (Exception e) {
                System.out.println("error loading window: " + e);
            }
        }

        ArrayList<Window> closedWindows = new ArrayList<>();
        while (controllers.size() > 0) {
            for (Controller controller : controllers) {
                boolean shouldClose = controller.window.updateWindow(controller.renderer);
                if (shouldClose) {
                    controller.window.restoreCursorIfDisabledOnWindow();
                    closedWindows.add(controller.window);
                }
            }

            if (closedWindows.size() > 0) {
                for (Window window : closedWindows) {
                    window.close();
                    controllers.removeIf(c -> c.window == window);
                }
                closedWindows.clear();
            }

            glfwPollEvents(); // i.e. processKeyboardEvents() for all windows
        }
    }


    public void createMainWindow() throws Exception {
        System.out.println("LWJGL version: " + Version.getVersion());

        Window window = new Window("Fire Olympics", 800, 600);

        window.init();
        System.out.println(window.openGlVersion());

        Path vertPath = resource("shaders", "shader.vert");
        Path fragPath = resource("shaders", "shader.frag");

        ShaderProgram program = new ShaderProgram(vertPath, fragPath);
        program.readCompileAndLink();
        program.createUniform("projectionMatrix");
        program.createUniform("worldMatrix");
        program.createUniform("sun");
        program.validate();

        ShaderProgram programWithTexture = new ShaderProgram(resource("shaders", "shader_with_texture.vert"),
                resource("shaders", "shader_with_texture.frag"));
        programWithTexture.readCompileAndLink();
        programWithTexture.createUniform("projectionMatrix");
        programWithTexture.createUniform("worldMatrix");
        programWithTexture.createUniform("sun");
        programWithTexture.createUniform("texture_sampler");
        programWithTexture.validate();

        ShaderProgram textShaderProgram = new ShaderProgram(resource("shaders", "shader_for_text.vert"), resource("shaders", "shader_for_text.frag"));
        textShaderProgram.readCompileAndLink();
        textShaderProgram.createUniform("colour");
        textShaderProgram.createUniform("translation");
        textShaderProgram.validate();

        FontFile fontFile = new FontFile(resource("fonts", "fontfile.fnt"));
        Texture texture = Texture.loadPngTexture(resource("fonts", "fontfile.png"));
        FontType fontType = new FontType(fontFile, texture);

        GUIText text = new GUIText("FIRE OLYMPICS", 5, fontType, new Vector2f(0f, 0f), 1f, true);
        text.setColour(0.0f, 0.5f, 0.5f);
        MeshText mesh = new MeshText(text);
        ModelLoader loader = new ModelLoader(resourcePath);
        Renderer renderer = new Renderer(program, programWithTexture, textShaderProgram);
        renderer.addText(mesh);
        Controller controller = new Controller(window, renderer, loader);
        controllers.add(controller);
    }

    public Path resource(String first, String... more) {
        return resourcePath.resolve(Path.of(first, more));
    }

    @Override
    public void close() {
        // Terminate GLFW and free the error callback
        glfwTerminate();
        Objects.requireNonNull(glfwSetErrorCallback(null)).free();
    }

    public static void checkError(String message) {
        int errorCode = glGetError();
        while (errorCode != GL_NO_ERROR) {
            String error;
            switch (errorCode) {
            case GL_INVALID_ENUM:
                error = "INVALID_ENUM";
                break;
            case GL_INVALID_VALUE:
                error = "INVALID_VALUE";
                break;
            case GL_INVALID_OPERATION:
                error = "INVALID_OPERATION";
                break;
            case GL_STACK_OVERFLOW:
                error = "STACK_OVERFLOW";
                break;
            case GL_STACK_UNDERFLOW:
                error = "STACK_UNDERFLOW";
                break;
            case GL_OUT_OF_MEMORY:
                error = "OUT_OF_MEMORY";
                break;
            case GL_INVALID_FRAMEBUFFER_OPERATION:
                error = "INVALID_FRAMEBUFFER_OPERATION";
                break;
            default:
                error = "unknown error code (" + errorCode + ")";
                break;
            }

            System.out.println(String.format("opengl error: %s, message: %s", error, message));
            errorCode = glGetError();
        }
    }
}
