/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package fire.olympics;

import fire.olympics.display.*;

import org.lwjgl.*;
import org.lwjgl.glfw.*;
import org.lwjgl.opengl.*;
import org.lwjgl.system.*;

import java.nio.*;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL33C.*;

public class App {
    private Path resourcePath = Path.of("app", "src", "main", "resources");

    public App() {
        if(!Files.exists(resourcePath))
            resourcePath = Path.of("app").relativize(resourcePath);
    }

    Window window;

    public void run() {
        System.out.println("LWJGL version: " + Version.getVersion());

        long window = -1;

        try {
            window = new Window();

            // todo: improve resource loading
            // At the moment this assumes the current working directory is the project directory,
            // is not necessarily true. Typically, the shaders would be included as resource files 
            // some how during the build. We could also watch for changes to the files and recompile
            // the shaders to make experimenting easier.

            Path vertPath = resourcePath.resolve(Path.of("shaders", "shader.vert"));
            Path fragPath = resourcePath.resolve(Path.of("shaders", "shader.frag"));

            ShaderProgram pipeline = new ShaderProgram(vertPath, fragPath);
            pipeline.readCompileAndLink();

            //float x, float y, float z, float length, float height, float width
            //Sample inputs. Follow the variables above to modify constraints
            float[] positions = GenerateModel.createPositions(0f,0f,0f,1f,1f,1f);
            int[] indices = GenerateModel.createIndicies();
            float[] colours = GenerateModel.createColours();

            // Create a gameItem
            gameItem[0] = new GameItem(new Mesh(positions,indices,colours));
            // This set the object to be behind the camera
            gameItem[0].setPosition(0,0, -2);
            try (Renderer render = new Renderer(window, pipeline)) {
                render.add(gameItem[0].getMesh());
                render.run();
            }
        } catch (Exception e) {
            System.out.printf("error: %s%n", e.toString());
        } finally {
            window.close();
        }
    }

    public static void main(String[] args) {
        Thread t = Thread.currentThread();
        if (!t.getName().equals("main")) {
            System.out.println("warning: not running on main thread!");
        }

        App app = new App();
        app.run();
    }
}
